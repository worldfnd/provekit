---
sidebar_position: 2
---

# SHA-256 Verification Example

This example demonstrates how to create zero-knowledge proofs for SHA-256 hash verification using ProveKit and Noir's built-in SHA-256 implementation.

## Overview

We'll create a circuit that:
1. Takes a private input message
2. Computes its SHA-256 hash
3. Proves knowledge of the message without revealing it

## Circuit Implementation

```rust
// src/main.nr
use std::hash::sha256;

fn main(
    message: [u8; 32],           // Private: the message we're hashing
    expected_hash: pub [u8; 32]  // Public: the expected SHA-256 result
) {
    // Compute SHA-256 hash of the message
    let computed_hash = sha256(message);
    
    // Assert that the computed hash matches the expected output
    assert(computed_hash == expected_hash);
}
```

## Setting Up the Project

Create a new Noir project:

```bash
mkdir sha256-example
cd sha256-example
nargo new sha256_circuit
cd sha256_circuit
```

Replace `src/main.nr` with the circuit above.

## Input Configuration

Create your input file (`Prover.toml`):

```toml
# Private input (secret message)
message = [
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
    0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
]  # "Hello World!" padded to 32 bytes

# Public input (known to verifier)
expected_hash = [
    0x7f, 0x83, 0xb1, 0x65, 0x7f, 0xf1, 0xfc, 0x53,
    0xb9, 0x2d, 0xc1, 0x81, 0x48, 0xa1, 0xd6, 0x5d,
    0xfc, 0x2d, 0x4b, 0x1f, 0xa3, 0xd6, 0x77, 0x28,
    0x4a, 0xdd, 0xd2, 0x00, 0x12, 0x6d, 0x90, 0x69
]  # SHA-256("Hello World!")
```

To compute the correct hash:

```bash
# Using command line
echo -n "Hello World!" | sha256sum

# Or let Noir compute it
nargo execute
cat target/Prover.toml
```

## Generating the Proof

### Step 1: Compile the Circuit

```bash
nargo compile
```

### Step 2: Prepare the Proof Scheme

```bash
cargo run --release --bin noir-r1cs prepare \
    ./target/sha256_circuit.json \
    -o ./sha256_scheme.nps
```

### Step 3: Generate the Proof

```bash
cargo run --release --bin noir-r1cs prove \
    ./sha256_scheme.nps \
    ./Prover.toml \
    -o ./sha256_proof.np
```

### Step 4: Verify the Proof

```bash
cargo run --release --bin noir-r1cs verify \
    ./sha256_scheme.nps \
    ./sha256_proof.np
```

## Expected Output

```
Circuit Analysis:
- Constraints: 28,252
- Witnesses: 14,186
- Public inputs: 32

Proof Generation:
- Time: 485ms
- Proof size: 12.4KB
- Memory usage: 185MB peak

âœ… Proof verification successful
Verification time: 18ms
```

## Advanced Examples

### Variable-Length Messages

```rust
// Hash messages of different lengths
use std::hash::sha256;

fn main(
    message: [u8; 64],           // Support up to 64 bytes
    message_length: pub Field,   // Actual message length
    expected_hash: pub [u8; 32]
) {
    // Create padded message based on length
    let mut padded_message = [0u8; 64];
    
    for i in 0..64 {
        if i < message_length as u32 {
            padded_message[i] = message[i];
        }
    }
    
    let computed_hash = sha256(padded_message);
    assert(computed_hash == expected_hash);
}
```

### Hash Chain Verification

```rust
// Verify a chain of SHA-256 hashes
fn main(
    initial_value: [u8; 32],
    num_iterations: pub Field,
    final_hash: pub [u8; 32]
) {
    let mut current = initial_value;
    
    for _i in 0..num_iterations {
        current = sha256(current);
    }
    
    assert(current == final_hash);
}
```

### Multi-Input SHA-256

```rust
// Hash concatenated inputs
fn main(
    input1: [u8; 32],
    input2: [u8; 32],
    combined_hash: pub [u8; 32]
) {
    // Concatenate inputs
    let mut combined = [0u8; 64];
    for i in 0..32 {
        combined[i] = input1[i];
        combined[i + 32] = input2[i];
    }
    
    let computed_hash = sha256(combined);
    assert(computed_hash == combined_hash);
}
```

## Performance Analysis

### Circuit Complexity
| Message Size | Constraints | Proof Time | Proof Size |
|--------------|-------------|------------|------------|
| 32 bytes | 28,252 | 485ms | 12.4KB |
| 64 bytes | 35,180 | 612ms | 13.1KB |
| 128 bytes | 49,036 | 865ms | 14.2KB |

### Scaling Behavior
- **Linear growth**: Each additional SHA-256 block adds ~7,000 constraints
- **Proof time**: Scales linearly with constraint count
- **Memory usage**: Significant for large messages (>100MB for 128 bytes)

## Use Cases

### 1. Document Integrity
Prove you possess a document with a specific hash:

```rust
fn main(document_content: [u8; 256], document_hash: pub [u8; 32]) {
    let computed_hash = sha256(document_content);
    assert(computed_hash == document_hash);
}
```

### 2. Password Verification
Prove you know a password without revealing it:

```rust
fn main(password: [u8; 32], password_hash: pub [u8; 32]) {
    let computed_hash = sha256(password);
    assert(computed_hash == password_hash);
}
```

### 3. Time-Lock Puzzles
Prove computation of a sequential hash chain:

```rust
fn main(
    secret: [u8; 32],
    iterations: pub Field,
    result: pub [u8; 32]
) {
    let mut current = secret;
    for _i in 0..iterations {
        current = sha256(current);
    }
    assert(current == result);
}
```

## Optimization Techniques

### Reduce Message Size
```rust
// Instead of hashing the full message, hash a commitment
fn main(
    message_hash: [u8; 32],      // Pre-computed hash of large message
    nonce: [u8; 32],
    commitment: pub [u8; 32]
) {
    let mut combined = [0u8; 64];
    for i in 0..32 {
        combined[i] = message_hash[i];
        combined[i + 32] = nonce[i];
    }
    
    let computed_commitment = sha256(combined);
    assert(computed_commitment == commitment);
}
```

### Batch Processing
```rust
// Verify multiple hashes in one proof
fn main(
    messages: [[u8; 32]; 10],
    hashes: pub [[u8; 32]; 10]
) {
    for i in 0..10 {
        let computed_hash = sha256(messages[i]);
        assert(computed_hash == hashes[i]);
    }
}
```

## Comparison with Poseidon

| Hash Function | Constraints | Proof Time | Security Model |
|---------------|-------------|------------|----------------|
| SHA-256 (32 bytes) | 28,252 | 485ms | Standard cryptographic assumptions |
| Poseidon (1 input) | 156 | 28ms | Algebraic assumptions |

**Trade-offs:**
- **SHA-256**: Slower but uses standard cryptographic assumptions
- **Poseidon**: Much faster but relies on newer algebraic assumptions

## Integration Example

```rust
use noir_r1cs::{NoirProofScheme, NoirProof};
use sha2::{Sha256, Digest};

pub struct DocumentVerifier {
    scheme: NoirProofScheme,
}

impl DocumentVerifier {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let scheme = NoirProofScheme::from_file("sha256_scheme.nps")?;
        Ok(Self { scheme })
    }
    
    pub fn prove_document_knowledge(
        &self,
        document: &[u8]
    ) -> Result<NoirProof, Box<dyn std::error::Error>> {
        // Compute SHA-256 hash
        let mut hasher = Sha256::new();
        hasher.update(document);
        let hash = hasher.finalize();
        
        // Create input file
        let input_content = format!(
            "message = {:?}\nexpected_hash = {:?}",
            document, hash.as_slice()
        );
        
        std::fs::write("temp_input.toml", input_content)?;
        
        // Generate proof
        let proof = self.scheme.prove("temp_input.toml")?;
        
        // Clean up
        std::fs::remove_file("temp_input.toml")?;
        
        Ok(proof)
    }
}
```

## Troubleshooting

### Common Issues

**Large constraint count:**
```bash
# SHA-256 generates many constraints
# Consider using Poseidon for better performance
# Or reduce message size
```

**Memory usage:**
```bash
# Monitor memory during proof generation
# Use streaming for very large circuits
export NOIR_R1CS_MEMORY_LIMIT=2GB
```

**Slow proof generation:**
```bash
# Ensure you're using release mode
cargo build --release

# Consider ARM64 hardware for better performance
```

## Next Steps

### Advanced Topics
- [Poseidon Hash Example](./poseidon-hash) - More efficient alternative
- [Performance Optimization](../performance/benchmarking) - Speed up proofs
- [Architecture Overview](../architecture/overview) - Understand the system

### Related Examples
- Password verification systems
- Document integrity proofs
- Blockchain applications

### Resources
- [SHA-256 Specification](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) - Official standard
- [Noir SHA-256 Implementation](https://noir-lang.org/docs/standard_library/cryptographic_primitives/hashes) - Standard library docs
